/* automatically generated by rust-bindgen 0.63.0 */

pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION64 {
    pub BaseAddress: ULONGLONG,
    pub AllocationBase: ULONGLONG,
    pub AllocationProtect: DWORD,
    pub __alignment1: DWORD,
    pub RegionSize: ULONGLONG,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
    pub __alignment2: DWORD,
}
pub type MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT64 {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: BYTE,
    pub Reserved1: BYTE,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: WORD,
    pub Reserved2: WORD,
    pub DataOffset: DWORD,
    pub DataSelector: WORD,
    pub Reserved3: WORD,
    pub MxCsr: DWORD,
    pub MxCsr_Mask: DWORD,
    pub FloatRegisters: [_M128A; 8usize],
    pub XmmRegisters: [_M128A; 16usize],
    pub Reserved4: [BYTE; 96usize],
}
impl Default for _XSAVE_FORMAT64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT64_2 {
    pub P1Home: DWORD64,
    pub P2Home: DWORD64,
    pub P3Home: DWORD64,
    pub P4Home: DWORD64,
    pub P5Home: DWORD64,
    pub P6Home: DWORD64,
    pub ContextFlags: DWORD,
    pub MxCsr: DWORD,
    pub SegCs: WORD,
    pub SegDs: WORD,
    pub SegEs: WORD,
    pub SegFs: WORD,
    pub SegGs: WORD,
    pub SegSs: WORD,
    pub EFlags: DWORD,
    pub Dr0: DWORD64,
    pub Dr1: DWORD64,
    pub Dr2: DWORD64,
    pub Dr3: DWORD64,
    pub Dr6: DWORD64,
    pub Dr7: DWORD64,
    pub Rax: DWORD64,
    pub Rcx: DWORD64,
    pub Rdx: DWORD64,
    pub Rbx: DWORD64,
    pub Rsp: DWORD64,
    pub Rbp: DWORD64,
    pub Rsi: DWORD64,
    pub Rdi: DWORD64,
    pub R8: DWORD64,
    pub R9: DWORD64,
    pub R10: DWORD64,
    pub R11: DWORD64,
    pub R12: DWORD64,
    pub R13: DWORD64,
    pub R14: DWORD64,
    pub R15: DWORD64,
    pub Rip: DWORD64,
    pub FltSave: _XSAVE_FORMAT64,
    pub Header: [_M128A; 2usize],
    pub Legacy: [_M128A; 8usize],
    pub Xmm0: _M128A,
    pub Xmm1: _M128A,
    pub Xmm2: _M128A,
    pub Xmm3: _M128A,
    pub Xmm4: _M128A,
    pub Xmm5: _M128A,
    pub Xmm6: _M128A,
    pub Xmm7: _M128A,
    pub Xmm8: _M128A,
    pub Xmm9: _M128A,
    pub Xmm10: _M128A,
    pub Xmm11: _M128A,
    pub Xmm12: _M128A,
    pub Xmm13: _M128A,
    pub Xmm14: _M128A,
    pub Xmm15: _M128A,
    pub VectorRegister: [_M128A; 26usize],
    pub VectorControl: DWORD64,
    pub DebugControl: DWORD64,
    pub LastBranchToRip: DWORD64,
    pub LastBranchFromRip: DWORD64,
    pub LastExceptionToRip: DWORD64,
    pub LastExceptionFromRip: DWORD64,
}
impl Default for _CONTEXT64_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn X64Call(func: DWORD64, argC: ::std::os::raw::c_int, ...) -> DWORD64;
}
extern "C" {
    pub fn GetModuleHandle64(lpModuleName: *const u16) -> DWORD64;
}
extern "C" {
    pub fn getNTDLL64() -> DWORD64;
}
extern "C" {
    pub fn GetProcAddress64(hModule: DWORD64, funcName: *const ::std::os::raw::c_char) -> DWORD64;
}
extern "C" {
    pub fn VirtualQueryEx64(
        hProcess: HANDLE,
        lpAddress: DWORD64,
        lpBuffer: *mut MEMORY_BASIC_INFORMATION64,
        dwLength: SIZE_T,
    ) -> SIZE_T;
}
extern "C" {
    pub fn VirtualAllocEx64(
        hProcess: HANDLE,
        lpAddress: DWORD64,
        dwSize: SIZE_T,
        flAllocationType: DWORD,
        flProtect: DWORD,
    ) -> DWORD64;
}
extern "C" {
    pub fn VirtualFreeEx64(
        hProcess: HANDLE,
        lpAddress: DWORD64,
        dwSize: SIZE_T,
        dwFreeType: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn VirtualProtectEx64(
        hProcess: HANDLE,
        lpAddress: DWORD64,
        dwSize: SIZE_T,
        flNewProtect: DWORD,
        lpflOldProtect: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadProcessMemory64(
        hProcess: HANDLE,
        lpBaseAddress: DWORD64,
        lpBuffer: LPVOID,
        nSize: SIZE_T,
        lpNumberOfBytesRead: *mut SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteProcessMemory64(
        hProcess: HANDLE,
        lpBaseAddress: DWORD64,
        lpBuffer: LPVOID,
        nSize: SIZE_T,
        lpNumberOfBytesWritten: *mut SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn GetThreadContext64(hThread: HANDLE, lpContext: *mut _CONTEXT64_2) -> BOOL;
}
extern "C" {
    pub fn SetThreadContext64(hThread: HANDLE, lpContext: *mut _CONTEXT64_2) -> BOOL;
}
extern "C" {
    pub fn SetLastErrorFromX64Call(status: DWORD64);
}
